---
layout: post
title: "学习linux启动过程"
date: 2013-01-15 09:50:01
comments: true
tags: [linux,kernel]
---
下一步需要学习动态的linux函数调用关系，所以得先从启动过程开始了解。从一本书**linux内核设计的艺术**中了解到的资料，以下内容如果不做特别注释的话，均为Linux0.11中的方式，可能新版本的kernel的函数名和这个会不一样，但是处理流程，我想应该每个操作系统都是一样的吧。

<!--more-->

## 从开机加电，到执行main函数之前的过程
好吧，这里应该是有执行3个汇编的文件，但是我不太了解。囧

## 从main函数，到启动OK（即可以响应用户操作了）
这个步骤做了3件事情：

* 创建进程0，使之具备在主机中进行运算的能力，2.1
* 已进程0为母本创建进程1，不仅有运算能力，而且还能以文件的行驶与外设进行数据交互，2.2-2.4
* 以进程1为母本创建进程2，全面具备进程1的能力和环境，进一步具备支持“人机交互”，实现怠速，2.5-2.8
 
### 开中断之前的准备工作
 1. 复制根设备号和硬盘参数表
 1. 物理内存规划格局：除了1MB以内的内核区之外，其余物理内存要完成的工作是不同的，对这三类不同性质的区域，在大小，位置，以及管理方式上进行规划
 	* “主内存区“：用来承载进程的相关信息，包括进程管理结构，进程对应的程序；
 	* “缓冲区”：主机与外设进行数据交互的中转站
 	* “虚拟盘区”：可选的区域，可将外设上的数据先复制到虚拟盘区，然后再使用。
 1. 虚拟盘设置与初始化：rd_init（某个设备请求的函数，对应到内核某块代码？？？？？）
 1. 内存管理结构mem_map初始化：mem_init,对于1MB以上的内存都是分页管理的。
 1. 异常处理类中断服务程序挂接：trap_init
 1. 初始化块设备请求项结构
 1. 与简历人机交互界面相关的外设的中断服务程序挂接
 	* 串行口设置
 	* 显示器设置
 	* 键盘设置
 1. 开机启动时间设置：进程0需要具备对时间的掌控能力，time_init()
 1. 系统开始激活进程0：sched_init函数开始
 	* 使其具备运算及创建其他进程的能力
 	* 时刻具备参与多进程轮询的能力
 	* 具备处理系统调用的能力
 1. 进程相关事务初始化设置：
 	* “任务状态描述符表”和“局部数据描述符表”挂接到全局描述附表GDT中
	* 对GDT和进程管理结构task[64]中除了与进程0相关的位置外，清空设置
	* 将GDT中关于进程0的“任务状态描述符”和“局部数据描述符”分别记录在CPU中的“任务状态寄存器”和“局部数据寄存器”中。
 1. 时钟中断设置
 1. 系统调用服务程序挂接：set_system_gate与中断描述符表挂接
 1. 初始化缓冲区管理结构
 1. 初始化硬盘hd_init,hd_interrupt
 1. 初始化软盘floppy_init
 1. 开中断:**系统中所有中断服务程序都已经和中断描述附表正常挂接**，中断服务构建完毕，系统可以在32位保护模式下处理中断信号了。


### 进程创建的最基本动作

 1. OS为进程0创建进程1做准备，
 	* move_to_user_mode,从内核态转换到用户态
 	* 上述函数后，相当于进行了一次中断返回，CS特权级从0转换到3，内核&rarr;用户
 	* 用户态的进程0，从LDT去的代码段描述符，与弹出的EIP组成线性地址
 	* 调用fork函数
 1. 在进程槽中为进程1申请一个空闲位置并且获取进程号
 	* find_empty_process，为进程1获得可用的进程号和空闲的任务号
 	* 全局变量last_pid存放系统开机以来累计的进程数。
 	* 内核的数据区中有个task[NR_TASKS]进程槽，存放task_struct指针。第一次遍历该数组，判断获得的进程号是否可用。ifyes,第二次遍历获得一个空的task_struct。linux0.11中，最多64个进程。
 1. 复制进程信息之前，先将一些数据压栈：将进程0的管理结构拷贝给进程1的管理结构
 	* copy_process
 1. 初步设置进程1管理结构
 	* 进程0的母本包括：“进程0的管理结构”，“进程0的页表项”
 1. 进程0创建进程1的过程中发生时钟中断（场景分析）
 	* 中断服务程序开始工作，跳转到_timer_interrupt执行，xxx压入进程0内核栈，保护现场
 	* _do_timer判断是否需要进程切换
 1. 从时钟中断返回
 	* ret_from_sys_call开始执行
 1. 调整进程1管理结构
 	* 进程0的管理结构数据信息不一定全都适用于进程1，还需针对具体情况调整。
 1. 设置进程1的线性地址空间及物理页面
 	* 创建页目录项和复制页表，从copy_mem开始
 	* copy_page_tables
 1. 调整进程1管理结构
 1. OS如何区分进程0和进程1
 	* _syscall0函数中，if(res>=0)这一行就是进程0中断返回后将要执行的第一行指令。。。
 	* 到底如何区分，我也没搞清楚。。。
 1. 进程0准备切换到进程1
 1. 系统切换到进程1执行


### 加载根文件系统（进程1来完成；原文中均有流程图说明）
 * 进程1通过对一些与硬盘管理相关的数据结构进行设置，进一步为进程依托系统与硬盘以文件行驶进行数据交互创造条件
 * 进程11用虚拟盘代替软盘，使之成为根设备
 * 进程1以虚拟盘中提供的数据为依据，加载根文件系统

--- 
 1. 开始执行：从_syscall0的if(__res>=0)这行代码开始,然后调用init函数
 1. 开始执行：在init中，先调用setup
 1. 进程1开始以数据块的形式操作硬盘
 1. 将找到的缓冲块与请求项挂接
 1. 将请求项与硬盘处理函数挂接
 1. 进行硬盘读盘前的准备工作
 1. 给硬盘下达读盘指令
 1. 进程1由于等待读盘操作挂起
 1. 系统切换到进程0执行
 1. 进程0的执行过程
 1. 进程0执行过程中发生硬盘中断
 1. 硬盘中断服务程序响应后，进程0继续执行
 1. 再次响应硬盘中断并唤醒进程1
 1. 读盘操作完成后，进程1继续执行
 1. 进程1继续设置硬盘管理结构
 1. 进程1获取软盘超级块，为加载根文件系统做准备
 1. 进程1备份超级快数据
 1. 进程1将根文件系统从软盘拷贝到虚拟盘
 1. 进程1开始加载根文件系统
 1. 进程1准备根文件系统超级块
 1. 进程1准备读取根目录i节点
 1. 进程1加载根目录i节点
 1。进程1结束加载根文件系统的过程

### 打开中断设备文件及复制文件句柄
 1. 进程1与内核文件表挂接，为打开文件做准备
 1. 确定打开操作的起点
 1. 获得枝梢i节点-dev目录文件的i节点
 1. 确定dev目录文件i节点为枝梢i节点
 1. 继续返回枝梢i节点
 1. 查找tty0文件的i节点
 1. 将tty0设备文件的i节点返回给sys_open系统调用
 1. 分析tty0文件i节点
 1. 设置文件管理结构并返回给用户进程
 1. 进程1复制tty0文件句柄

### 创建进程2


### 进程1等待进程2退出


### shell程序的加载


### 系统实现怠速